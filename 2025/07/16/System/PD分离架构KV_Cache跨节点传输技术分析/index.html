<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="PD分离架构KV Cache跨节点传输技术深度分析概述本文深入分析TensorRT-LLM、vLLM和SGLang三个主流LLM服务框架中Prefill-Decode (PD) 分离架构的KV Cache跨节点传输功能实现。PD分离架构通过将计算密集型的预填充(Prefill)和内存密集型的解码(Decode)阶段分离到不同节点，实现了更好的资源利用和性能优化。 核心技术挑战1. 网络通信挑战 高">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/07/16/System/PD%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84KV_Cache%E8%B7%A8%E8%8A%82%E7%82%B9%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="PD分离架构KV Cache跨节点传输技术深度分析概述本文深入分析TensorRT-LLM、vLLM和SGLang三个主流LLM服务框架中Prefill-Decode (PD) 分离架构的KV Cache跨节点传输功能实现。PD分离架构通过将计算密集型的预填充(Prefill)和内存密集型的解码(Decode)阶段分离到不同节点，实现了更好的资源利用和性能优化。 核心技术挑战1. 网络通信挑战 高">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-16T02:11:51.910Z">
<meta property="article:modified_time" content="2025-07-16T09:34:06.098Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

  
  <!-- Mermaid -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default',
      securityLevel: 'loose',
      themeVariables: {
        primaryColor: '#0f4c75',
        primaryTextColor: '#fff',
        primaryBorderColor: '#0f4c75',
        lineColor: '#0f4c75',
        secondaryColor: '#006ba6',
        tertiaryColor: '#fff'
      }
    });
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-System/PD分离架构KV_Cache跨节点传输技术分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/16/System/PD%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84KV_Cache%E8%B7%A8%E8%8A%82%E7%82%B9%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2025-07-16T02:11:51.910Z" itemprop="datePublished">2025-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PD分离架构KV-Cache跨节点传输技术深度分析"><a href="#PD分离架构KV-Cache跨节点传输技术深度分析" class="headerlink" title="PD分离架构KV Cache跨节点传输技术深度分析"></a>PD分离架构KV Cache跨节点传输技术深度分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文深入分析TensorRT-LLM、vLLM和SGLang三个主流LLM服务框架中Prefill-Decode (PD) 分离架构的KV Cache跨节点传输功能实现。PD分离架构通过将计算密集型的预填充(Prefill)和内存密集型的解码(Decode)阶段分离到不同节点，实现了更好的资源利用和性能优化。</p>
<h2 id="核心技术挑战"><a href="#核心技术挑战" class="headerlink" title="核心技术挑战"></a>核心技术挑战</h2><h3 id="1-网络通信挑战"><a href="#1-网络通信挑战" class="headerlink" title="1. 网络通信挑战"></a>1. 网络通信挑战</h3><ul>
<li><strong>高带宽需求</strong>: KV Cache数据量巨大，需要高效的网络传输</li>
<li><strong>低延迟要求</strong>: 传输延迟直接影响首Token时间(TTFT)</li>
<li><strong>并发传输</strong>: 多个请求同时传输KV Cache的并发处理</li>
</ul>
<h3 id="2-数据序列化挑战"><a href="#2-数据序列化挑战" class="headerlink" title="2. 数据序列化挑战"></a>2. 数据序列化挑战</h3><ul>
<li><strong>Tensor序列化</strong>: 需要高效的张量序列化&#x2F;反序列化机制</li>
<li><strong>内存布局</strong>: 不同设备和内存布局的兼容性</li>
<li><strong>数据完整性</strong>: 网络传输过程中的数据完整性保证</li>
</ul>
<h3 id="3-系统架构挑战"><a href="#3-系统架构挑战" class="headerlink" title="3. 系统架构挑战"></a>3. 系统架构挑战</h3><ul>
<li><strong>节点发现</strong>: 动态的节点发现和连接管理</li>
<li><strong>负载均衡</strong>: 多个Prefill&#x2F;Decode节点的负载均衡</li>
<li><strong>容错处理</strong>: 节点故障时的容错和恢复机制</li>
</ul>
<h2 id="TensorRT-LLM实现分析"><a href="#TensorRT-LLM实现分析" class="headerlink" title="TensorRT-LLM实现分析"></a>TensorRT-LLM实现分析</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><p>TensorRT-LLM采用了<strong>分层Cache传输架构</strong>，支持多种通信后端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心传输管理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheTransceiver</span> &#123;</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">CommType</span> &#123;</span><br><span class="line">        UCX,    <span class="comment">// UCX通信</span></span><br><span class="line">        NIXL,   <span class="comment">// NIXL通信  </span></span><br><span class="line">        MPI     <span class="comment">// MPI通信</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::unique_ptr&lt;DataResponder&gt; mDataResponder;</span><br><span class="line">    std::unique_ptr&lt;DataRequester&gt; mDataRequester;</span><br><span class="line">    std::unique_ptr&lt;executor::kv_cache::ConnectionManager&gt; mManager;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="网络通信实现"><a href="#网络通信实现" class="headerlink" title="网络通信实现"></a>网络通信实现</h3><h4 id="1-多协议支持"><a href="#1-多协议支持" class="headerlink" title="1. 多协议支持"></a>1. 多协议支持</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通信协议选择</span></span><br><span class="line"><span class="keyword">if</span> (common::<span class="built_in">getEnvUseUCXKvCache</span>()) &#123;</span><br><span class="line">    commType = CacheTransceiver::CommType::UCX;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (common::<span class="built_in">getEnvUseNixlKvCache</span>()) &#123;</span><br><span class="line">    commType = CacheTransceiver::CommType::NIXL;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (common::<span class="built_in">getEnvUseMPIKvCache</span>()) &#123;</span><br><span class="line">    commType = CacheTransceiver::CommType::MPI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Zero-Copy优化"><a href="#2-Zero-Copy优化" class="headerlink" title="2. Zero-Copy优化"></a>2. Zero-Copy优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zero-Copy传输优化</span></span><br><span class="line"><span class="keyword">if</span> (common::<span class="built_in">getEnvTryZCopyForKVCacheTransfer</span>() &amp;&amp; </span><br><span class="line">    destConfig == selfConfig) &#123;</span><br><span class="line">    <span class="comment">// 直接GPU到GPU传输，避免CPU拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; connection : connections) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; block : outputBuffers) &#123;</span><br><span class="line">            TransferHelper::<span class="built_in">recvBuffer</span>(*connection, *block, reqId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-并行传输"><a href="#3-并行传输" class="headerlink" title="3. 并行传输"></a>3. 并行传输</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发传输优化</span></span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sendConcurrencyNum; i++) &#123;</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, </span><br><span class="line">        sendBufferFun, deviceId, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化机制"><a href="#序列化机制" class="headerlink" title="序列化机制"></a>序列化机制</h3><h4 id="1-请求信息序列化"><a href="#1-请求信息序列化" class="headerlink" title="1. 请求信息序列化"></a>1. 请求信息序列化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化请求信息</span></span><br><span class="line"><span class="function">RequestInfo <span class="title">requestInfo</span><span class="params">(requestId, mSelfState)</span></span>;</span><br><span class="line">std::ostringstream oss;</span><br><span class="line">RequestInfo::<span class="built_in">serialize</span>(info, oss);</span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span>&amp; serializedInfo = oss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-分块传输"><a href="#2-分块传输" class="headerlink" title="2. 分块传输"></a>2. 分块传输</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分块传输大型KV Cache</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> targetBufferSize = allCacheBlockSize / targetNum;</span><br><span class="line"><span class="keyword">auto</span> result = mCacheTransBufferManager-&gt;<span class="built_in">getOrAllocateSendBuffers</span>(</span><br><span class="line">    cacheBufferId, bufferTargetNum, targetBufferSize, bufferManager);</span><br></pre></td></tr></table></figure>

<h3 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h3><h4 id="1-传输重叠"><a href="#1-传输重叠" class="headerlink" title="1. 传输重叠"></a>1. 传输重叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持传输与计算重叠</span></span><br><span class="line"><span class="keyword">if</span> (common::<span class="built_in">getEnvDisableKVCacheTransferOverlap</span>()) &#123;</span><br><span class="line">    mCacheTransceiver-&gt;<span class="built_in">requestAndReceiveSync</span>(newGenReq.<span class="built_in">get</span>());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mCacheTransceiver-&gt;<span class="built_in">requestAndReceiveAsync</span>(newGenReq.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-选择性传输"><a href="#2-选择性传输" class="headerlink" title="2. 选择性传输"></a>2. 选择性传输</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择性Cache传输，只传输新分配的块</span></span><br><span class="line"><span class="keyword">if</span> (!disableSelectiveCacheTransfer) &#123;</span><br><span class="line">    <span class="keyword">auto</span> blockRange = BlockRange::<span class="built_in">fromNewlyAllocatedBlockIds</span>(</span><br><span class="line">        *cacheManager, llmRequest.mRequestId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vLLM实现分析"><a href="#vLLM实现分析" class="headerlink" title="vLLM实现分析"></a>vLLM实现分析</h2><h3 id="核心架构-1"><a href="#核心架构-1" class="headerlink" title="核心架构"></a>核心架构</h3><p>vLLM采用了<strong>三层抽象架构</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三层抽象</span></span><br><span class="line"><span class="number">1.</span> KV pipe: FIFO管道，用于tensor传输</span><br><span class="line"><span class="number">2.</span> KV lookup buffer: 查找缓冲区，键值对存储</span><br><span class="line"><span class="number">3.</span> KV connector: 连接器，集成vLLM模型执行</span><br></pre></td></tr></table></figure>

<h3 id="网络通信实现-1"><a href="#网络通信实现-1" class="headerlink" title="网络通信实现"></a>网络通信实现</h3><h4 id="1-多连接器支持"><a href="#1-多连接器支持" class="headerlink" title="1. 多连接器支持"></a>1. 多连接器支持</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持多种连接器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KVTransferConfig</span>:</span><br><span class="line">    kv_connector: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>  <span class="comment"># &quot;PyNcclConnector&quot;, &quot;SharedStorageConnector&quot;</span></span><br><span class="line">    kv_role: <span class="type">Optional</span>[KVRole] = <span class="literal">None</span>   <span class="comment"># &quot;kv_producer&quot;, &quot;kv_consumer&quot;, &quot;kv_both&quot;</span></span><br><span class="line">    kv_rank: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>      <span class="comment"># 节点rank</span></span><br><span class="line">    kv_parallel_size: <span class="built_in">int</span> = <span class="number">1</span>          <span class="comment"># 并行实例数</span></span><br></pre></td></tr></table></figure>

<h4 id="2-分布式KV传输"><a href="#2-分布式KV传输" class="headerlink" title="2. 分布式KV传输"></a>2. 分布式KV传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分布式KV传输示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_prefill</span>(<span class="params">prefill_done</span>):</span><br><span class="line">    ktc = KVTransferConfig(</span><br><span class="line">        kv_connector=<span class="string">&quot;PyNcclConnector&quot;</span>,</span><br><span class="line">        kv_role=<span class="string">&quot;kv_producer&quot;</span>,</span><br><span class="line">        kv_rank=<span class="number">0</span>,</span><br><span class="line">        kv_parallel_size=<span class="number">2</span>,</span><br><span class="line">    )</span><br><span class="line">    llm = LLM(model=<span class="string">&quot;meta-llama/Meta-Llama-3.1-8B-Instruct&quot;</span>,</span><br><span class="line">              kv_transfer_config=ktc)</span><br></pre></td></tr></table></figure>

<h3 id="序列化机制-1"><a href="#序列化机制-1" class="headerlink" title="序列化机制"></a>序列化机制</h3><h4 id="1-高效Tensor序列化"><a href="#1-高效Tensor序列化" class="headerlink" title="1. 高效Tensor序列化"></a>1. 高效Tensor序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgpackEncoder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode_tensor</span>(<span class="params">self, obj: torch.Tensor</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="comment"># 大张量使用零拷贝</span></span><br><span class="line">        <span class="keyword">if</span> obj.numel() * obj.element_size() &gt;= <span class="variable language_">self</span>.size_threshold:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._encode_large_tensor(obj)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._encode_small_tensor(obj)</span><br></pre></td></tr></table></figure>

<h4 id="2-多模态数据序列化"><a href="#2-多模态数据序列化" class="headerlink" title="2. 多模态数据序列化"></a>2. 多模态数据序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持多模态数据的序列化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_hook</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, torch.Tensor):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._encode_tensor(obj)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(obj, np.ndarray):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._encode_ndarray(obj)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(obj, MultiModalKwargs):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._encode_multimodal(obj)</span><br></pre></td></tr></table></figure>

<h3 id="传输优化"><a href="#传输优化" class="headerlink" title="传输优化"></a>传输优化</h3><h4 id="1-零拷贝传输"><a href="#1-零拷贝传输" class="headerlink" title="1. 零拷贝传输"></a>1. 零拷贝传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用零拷贝技术减少内存拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgpackEncoder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="type">Sequence</span>[bytestr]:</span><br><span class="line">        <span class="comment"># 收集直接缓冲区指针，避免数据拷贝</span></span><br><span class="line">        <span class="variable language_">self</span>.aux_buffers = bufs = [<span class="string">b&#x27;&#x27;</span>]</span><br><span class="line">        bufs[<span class="number">0</span>] = <span class="variable language_">self</span>.encoder.encode(obj)</span><br><span class="line">        <span class="keyword">return</span> bufs</span><br></pre></td></tr></table></figure>

<h4 id="2-异步传输"><a href="#2-异步传输" class="headerlink" title="2. 异步传输"></a>2. 异步传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步KV传输</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">recv_kv_caches_and_hidden_states</span>(<span class="params">self, model_executable, </span></span><br><span class="line"><span class="params">                                          model_input, kv_caches</span>):</span><br><span class="line">    <span class="comment"># 异步接收KV缓存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">self</span>.connector.recv_kv_caches_and_hidden_states(</span><br><span class="line">        model_executable, model_input, kv_caches)</span><br></pre></td></tr></table></figure>

<h2 id="SGLang实现分析"><a href="#SGLang实现分析" class="headerlink" title="SGLang实现分析"></a>SGLang实现分析</h2><h3 id="核心架构-2"><a href="#核心架构-2" class="headerlink" title="核心架构"></a>核心架构</h3><p>SGLang采用了<strong>模块化传输引擎架构</strong>，支持Mooncake和NIXL两种传输引擎：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传输引擎选择</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransferBackend</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    MOONCAKE = <span class="string">&quot;mooncake&quot;</span></span><br><span class="line">    NIXL = <span class="string">&quot;nixl&quot;</span></span><br><span class="line">    ASCEND = <span class="string">&quot;ascend&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="网络通信实现-2"><a href="#网络通信实现-2" class="headerlink" title="网络通信实现"></a>网络通信实现</h3><h4 id="1-RDMA高速传输"><a href="#1-RDMA高速传输" class="headerlink" title="1. RDMA高速传输"></a>1. RDMA高速传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NIXL RDMA传输实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NixlKVManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_kvcache</span>(<span class="params">self, peer_name: <span class="built_in">str</span>, prefill_kv_indices, </span></span><br><span class="line"><span class="params">                     dst_kv_ptrs, dst_kv_indices, dst_gpu_id, notif: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># 分组连续传输</span></span><br><span class="line">        prefill_kv_blocks, dst_kv_blocks = group_concurrent_contiguous(</span><br><span class="line">            prefill_kv_indices, dst_kv_indices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建RDMA传输描述符</span></span><br><span class="line">        src_descs = <span class="variable language_">self</span>.agent.get_xfer_descs(src_addrs, <span class="string">&quot;VRAM&quot;</span>)</span><br><span class="line">        dst_descs = <span class="variable language_">self</span>.agent.get_xfer_descs(dst_addrs, <span class="string">&quot;VRAM&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 执行RDMA传输</span></span><br><span class="line">        xfer_handle = <span class="variable language_">self</span>.agent.initialize_xfer(</span><br><span class="line">            <span class="string">&quot;WRITE&quot;</span>, src_descs, dst_descs, peer_name, notif)</span><br></pre></td></tr></table></figure>

<h4 id="2-多节点协调"><a href="#2-多节点协调" class="headerlink" title="2. 多节点协调"></a>2. 多节点协调</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多节点协调机制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonKVManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args, disaggregation_mode, server_args</span>):</span><br><span class="line">        <span class="variable language_">self</span>.bootstrap_port = server_args.disaggregation_bootstrap_port</span><br><span class="line">        <span class="variable language_">self</span>.connection_pool = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.prefill_tp_size_table = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> disaggregation_mode == DisaggregationMode.PREFILL:</span><br><span class="line">            <span class="variable language_">self</span>._register_to_bootstrap()</span><br><span class="line">        <span class="keyword">elif</span> disaggregation_mode == DisaggregationMode.DECODE:</span><br><span class="line">            <span class="variable language_">self</span>._init_decode_connections()</span><br></pre></td></tr></table></figure>

<h3 id="传输优化策略"><a href="#传输优化策略" class="headerlink" title="传输优化策略"></a>传输优化策略</h3><h4 id="1-分层传输"><a href="#1-分层传输" class="headerlink" title="1. 分层传输"></a>1. 分层传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mooncake分层传输</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_layer_tp_aware</span>(<span class="params">layer_params</span>):</span><br><span class="line">    <span class="keyword">for</span> layer_id <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">        <span class="comment"># 逐层传输，减少内存峰值</span></span><br><span class="line">        status = <span class="variable language_">self</span>.engine.batch_transfer_sync(</span><br><span class="line">            session_id, src_addr_list, dst_addr_list, length_list)</span><br></pre></td></tr></table></figure>

<h4 id="2-并发传输"><a href="#2-并发传输" class="headerlink" title="2. 并发传输"></a>2. 并发传输</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并发传输优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_kvcache_slice</span>(<span class="params">self, session_id, prefill_kv_indices, </span></span><br><span class="line"><span class="params">                       dst_kv_ptrs, dst_kv_indices</span>):</span><br><span class="line">    <span class="comment"># 使用线程池并发传输</span></span><br><span class="line">    futures = [executor.submit(process_layer, src_ptr, dst_ptr, item_len)</span><br><span class="line">               <span class="keyword">for</span> (src_ptr, dst_ptr, item_len) <span class="keyword">in</span> layers_params]</span><br></pre></td></tr></table></figure>

<h3 id="容错与监控"><a href="#容错与监控" class="headerlink" title="容错与监控"></a>容错与监控</h3><h4 id="1-心跳机制"><a href="#1-心跳机制" class="headerlink" title="1. 心跳机制"></a>1. 心跳机制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 心跳检测机制</span></span><br><span class="line">SGLANG_DISAGGREGATION_HEARTBEAT_INTERVAL = <span class="number">5.0</span>  <span class="comment"># 心跳间隔</span></span><br><span class="line">SGLANG_DISAGGREGATION_HEARTBEAT_MAX_FAILURE = <span class="number">2</span>  <span class="comment"># 最大失败次数</span></span><br></pre></td></tr></table></figure>

<h4 id="2-超时处理"><a href="#2-超时处理" class="headerlink" title="2. 超时处理"></a>2. 超时处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时处理配置</span></span><br><span class="line">SGLANG_DISAGGREGATION_BOOTSTRAP_TIMEOUT = <span class="number">300</span>    <span class="comment"># 启动超时</span></span><br><span class="line">SGLANG_DISAGGREGATION_WAITING_TIMEOUT = <span class="number">300</span>      <span class="comment"># 等待超时</span></span><br></pre></td></tr></table></figure>

<h2 id="跨框架技术对比"><a href="#跨框架技术对比" class="headerlink" title="跨框架技术对比"></a>跨框架技术对比</h2><h3 id="1-通信协议支持"><a href="#1-通信协议支持" class="headerlink" title="1. 通信协议支持"></a>1. 通信协议支持</h3><table>
<thead>
<tr>
<th>框架</th>
<th>支持协议</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>TensorRT-LLM</td>
<td>UCX、NIXL、MPI</td>
<td>多协议支持，企业级稳定性</td>
</tr>
<tr>
<td>vLLM</td>
<td>PyNCCL、SharedStorage</td>
<td>简洁易用，Python生态</td>
</tr>
<tr>
<td>SGLang</td>
<td>Mooncake、NIXL</td>
<td>高性能RDMA，云原生</td>
</tr>
</tbody></table>
<h3 id="2-序列化机制"><a href="#2-序列化机制" class="headerlink" title="2. 序列化机制"></a>2. 序列化机制</h3><table>
<thead>
<tr>
<th>框架</th>
<th>序列化方式</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>TensorRT-LLM</td>
<td>原生C++序列化</td>
<td>高性能，内存效率高</td>
</tr>
<tr>
<td>vLLM</td>
<td>Msgpack + 零拷贝</td>
<td>跨语言兼容，灵活性好</td>
</tr>
<tr>
<td>SGLang</td>
<td>SafeTensors</td>
<td>安全性高，格式标准化</td>
</tr>
</tbody></table>
<h3 id="3-性能优化策略"><a href="#3-性能优化策略" class="headerlink" title="3. 性能优化策略"></a>3. 性能优化策略</h3><table>
<thead>
<tr>
<th>优化技术</th>
<th>TensorRT-LLM</th>
<th>vLLM</th>
<th>SGLang</th>
</tr>
</thead>
<tbody><tr>
<td>Zero-Copy</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>异步传输</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>并行传输</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>选择性传输</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>分层传输</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>RDMA支持</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="核心代码实现详解"><a href="#核心代码实现详解" class="headerlink" title="核心代码实现详解"></a>核心代码实现详解</h2><h3 id="TensorRT-LLM传输核心"><a href="#TensorRT-LLM传输核心" class="headerlink" title="TensorRT-LLM传输核心"></a>TensorRT-LLM传输核心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheFormatter::formatOutput</span><span class="params">(LlmRequest <span class="type">const</span>&amp; llmRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;executor::kv_cache::Connection <span class="type">const</span>*&gt; <span class="type">const</span>&amp; connections,</span></span></span><br><span class="line"><span class="params"><span class="function">    CacheState <span class="type">const</span>&amp; selfConfig, SizeType32 selfIdx, </span></span></span><br><span class="line"><span class="params"><span class="function">    CacheState <span class="type">const</span>&amp; destConfig, runtime::BufferManager <span class="type">const</span>&amp; bufferManager)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取传输块范围</span></span><br><span class="line">    <span class="keyword">auto</span> blockRange = <span class="built_in">getBlockRangeForSending</span>(mCacheManager, llmRequest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否支持零拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (common::<span class="built_in">getEnvTryZCopyForKVCacheTransfer</span>() &amp;&amp; </span><br><span class="line">        destConfig == selfConfig) &#123;</span><br><span class="line">        <span class="comment">// 零拷贝传输</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; connection : connections) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; block : inputKvCacheBlocks) &#123;</span><br><span class="line">                TransferHelper::<span class="built_in">sendBuffer</span>(*connection, *block, reqId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 分块传输</span></span><br><span class="line">    <span class="keyword">auto</span> targetBufferSize = allCacheBlockSize / targetNum;</span><br><span class="line">    <span class="keyword">auto</span> result = mCacheTransBufferManager-&gt;<span class="built_in">getOrAllocateSendBuffers</span>(</span><br><span class="line">        cacheBufferId, bufferTargetNum, targetBufferSize, bufferManager);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 并行传输</span></span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sendConcurrencyNum; i++) &#123;</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, </span><br><span class="line">            sendBufferFun, deviceId, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vLLM传输核心"><a href="#vLLM传输核心" class="headerlink" title="vLLM传输核心"></a>vLLM传输核心</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KVTransferAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_kv_caches_and_hidden_states</span>(<span class="params">self, model_executable, </span></span><br><span class="line"><span class="params">                                        model_input, kv_caches, </span></span><br><span class="line"><span class="params">                                        hidden_or_intermediate_states</span>):</span><br><span class="line">        <span class="comment"># 调用底层连接器传输</span></span><br><span class="line">        <span class="variable language_">self</span>.connector.send_kv_caches_and_hidden_states(</span><br><span class="line">            model_executable, model_input, kv_caches, </span><br><span class="line">            hidden_or_intermediate_states)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_kv_caches_and_hidden_states</span>(<span class="params">self, model_executable, </span></span><br><span class="line"><span class="params">                                       model_input, kv_caches</span>):</span><br><span class="line">        <span class="comment"># 接收KV缓存和隐藏状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.connector.recv_kv_caches_and_hidden_states(</span><br><span class="line">            model_executable, model_input, kv_caches)</span><br></pre></td></tr></table></figure>

<h3 id="SGLang传输核心"><a href="#SGLang传输核心" class="headerlink" title="SGLang传输核心"></a>SGLang传输核心</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MooncakeKVManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_kvcache</span>(<span class="params">self, session_id, prefill_kv_indices, </span></span><br><span class="line"><span class="params">                     dst_kv_ptrs, dst_kv_indices, executor</span>):</span><br><span class="line">        <span class="comment"># 分组连续块</span></span><br><span class="line">        prefill_kv_blocks, dst_kv_blocks = group_concurrent_contiguous(</span><br><span class="line">            prefill_kv_indices, dst_kv_indices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 并行传输层</span></span><br><span class="line">        futures = [executor.submit(<span class="variable language_">self</span>.process_layer, src_ptr, dst_ptr, item_len)</span><br><span class="line">                   <span class="keyword">for</span> (src_ptr, dst_ptr, item_len) <span class="keyword">in</span> layers_params]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待传输完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">            status = future.result()</span><br><span class="line">            <span class="keyword">if</span> status != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> TransferException(<span class="string">f&quot;Transfer failed: <span class="subst">&#123;status&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="技术发展趋势"><a href="#技术发展趋势" class="headerlink" title="技术发展趋势"></a>技术发展趋势</h2><h3 id="1-硬件加速"><a href="#1-硬件加速" class="headerlink" title="1. 硬件加速"></a>1. 硬件加速</h3><ul>
<li><strong>RDMA集成</strong>: 更深度的RDMA硬件加速集成</li>
<li><strong>专用硬件</strong>: 专门的KV Cache传输硬件</li>
<li><strong>内存池化</strong>: 跨节点内存池化技术</li>
</ul>
<h3 id="2-协议优化"><a href="#2-协议优化" class="headerlink" title="2. 协议优化"></a>2. 协议优化</h3><ul>
<li><strong>自定义协议</strong>: 针对LLM优化的专用传输协议</li>
<li><strong>压缩传输</strong>: 智能压缩算法减少传输数据量</li>
<li><strong>差异传输</strong>: 只传输变化的KV Cache部分</li>
</ul>
<h3 id="3-系统架构"><a href="#3-系统架构" class="headerlink" title="3. 系统架构"></a>3. 系统架构</h3><ul>
<li><strong>弹性伸缩</strong>: 动态节点伸缩支持</li>
<li><strong>多级缓存</strong>: 分层的KV Cache存储架构</li>
<li><strong>边缘计算</strong>: 边缘节点的KV Cache共享</li>
</ul>
<h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="1-框架选择"><a href="#1-框架选择" class="headerlink" title="1. 框架选择"></a>1. 框架选择</h3><ul>
<li><strong>TensorRT-LLM</strong>: 适合企业级部署，需要高稳定性</li>
<li><strong>vLLM</strong>: 适合研究和快速原型开发</li>
<li><strong>SGLang</strong>: 适合高性能场景，需要RDMA支持</li>
</ul>
<h3 id="2-网络配置"><a href="#2-网络配置" class="headerlink" title="2. 网络配置"></a>2. 网络配置</h3><ul>
<li><strong>带宽</strong>: 至少10Gbps，推荐40Gbps以上</li>
<li><strong>延迟</strong>: 尽量使用低延迟网络设备</li>
<li><strong>拓扑</strong>: 采用胖树或全连接网络拓扑</li>
</ul>
<h3 id="3-调优参数"><a href="#3-调优参数" class="headerlink" title="3. 调优参数"></a>3. 调优参数</h3><ul>
<li><strong>并发度</strong>: 根据网络带宽调整并发传输数</li>
<li><strong>块大小</strong>: 平衡内存占用和传输效率</li>
<li><strong>超时设置</strong>: 根据网络条件设置合适的超时值</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>三个框架都实现了各具特色的PD分离架构KV Cache跨节点传输功能：</p>
<ol>
<li><strong>TensorRT-LLM</strong>提供了最完整的企业级解决方案，支持多种通信协议和丰富的优化策略</li>
<li><strong>vLLM</strong>采用了简洁的三层抽象架构，具有良好的可扩展性和易用性</li>
<li><strong>SGLang</strong>专注于高性能场景，提供了先进的RDMA传输和云原生支持</li>
</ol>
<p>在实际应用中，应根据具体需求选择合适的框架，并结合硬件特性进行针对性优化。随着技术的发展，预计未来会有更多创新的传输技术和系统架构出现。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/16/System/PD%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84KV_Cache%E8%B7%A8%E8%8A%82%E7%82%B9%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/" data-id="cme16wf3p001pruone67c6lem" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/07/16/System/vLLM_PagedAttention_%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/07/16/System/KVCache%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/System/">System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Test/">Test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Attention/" rel="tag">Attention</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Communication/" rel="tag">Communication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/" rel="tag">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computational-Graph/" rel="tag">Computational Graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeepSeek/" rel="tag">DeepSeek</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/" rel="tag">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MoE/" rel="tag">MoE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Optimization/" rel="tag">Optimization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGLang/" rel="tag">SGLang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System/" rel="tag">System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blues/" rel="tag">blues</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/career/" rel="tag">career</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/charts/" rel="tag">charts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consensus/" rel="tag">consensus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-parallelism/" rel="tag">data-parallelism</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed-systems/" rel="tag">distributed-systems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/experience/" rel="tag">experience</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/expert-parallelism/" rel="tag">expert-parallelism</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/guitar/" rel="tag">guitar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/harmony/" rel="tag">harmony</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/licks/" rel="tag">licks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/" rel="tag">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llm/" rel="tag">llm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mermaid/" rel="tag">mermaid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rhythm/" rel="tag">rhythm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/Attention/" style="font-size: 10px;">Attention</a> <a href="/tags/Communication/" style="font-size: 10px;">Communication</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Computational-Graph/" style="font-size: 10px;">Computational Graph</a> <a href="/tags/DeepSeek/" style="font-size: 10px;">DeepSeek</a> <a href="/tags/Distributed/" style="font-size: 10px;">Distributed</a> <a href="/tags/LLM/" style="font-size: 10px;">LLM</a> <a href="/tags/MoE/" style="font-size: 10px;">MoE</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/SGLang/" style="font-size: 10px;">SGLang</a> <a href="/tags/System/" style="font-size: 15px;">System</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/blues/" style="font-size: 20px;">blues</a> <a href="/tags/career/" style="font-size: 10px;">career</a> <a href="/tags/charts/" style="font-size: 10px;">charts</a> <a href="/tags/consensus/" style="font-size: 10px;">consensus</a> <a href="/tags/data-parallelism/" style="font-size: 10px;">data-parallelism</a> <a href="/tags/distributed-systems/" style="font-size: 20px;">distributed-systems</a> <a href="/tags/experience/" style="font-size: 10px;">experience</a> <a href="/tags/expert-parallelism/" style="font-size: 10px;">expert-parallelism</a> <a href="/tags/guitar/" style="font-size: 20px;">guitar</a> <a href="/tags/harmony/" style="font-size: 10px;">harmony</a> <a href="/tags/licks/" style="font-size: 10px;">licks</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/llm/" style="font-size: 15px;">llm</a> <a href="/tags/mermaid/" style="font-size: 10px;">mermaid</a> <a href="/tags/raft/" style="font-size: 10px;">raft</a> <a href="/tags/rhythm/" style="font-size: 10px;">rhythm</a> <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/03/Plans/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%BE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/08/02/System/LLM%20Serving%20Configs/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/07/31/System/cuda-kernel/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/07/31/Programming/CPP/constexpr/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/07/30/System/%E5%B9%B6%E8%A1%8C%E7%AD%96%E7%95%A5/%E5%BA%8F%E5%88%97%E5%B9%B6%E8%A1%8C/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






<!-- Mermaid Support -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    securityLevel: 'loose',
    themeVariables: {
      primaryColor: '#0f4c75',
      primaryTextColor: '#fff',
      primaryBorderColor: '#0f4c75',
      lineColor: '#0f4c75',
      secondaryColor: '#006ba6',
      tertiaryColor: '#fff'
    }
  });
</script>
  </div>
</body>
</html>